{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user within the StudySync application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "name": {
          "type": "string",
          "description": "The user's display name."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        },
        "role": {
          "type": "string",
          "description": "The user's role within the application (e.g., 'student', 'admin')."
        },
        "joinDate": {
          "type": "string",
          "description": "The date and time the user joined the application.",
          "format": "date-time"
        },
        "lastActive": {
          "type": "string",
          "description": "The date and time the user was last active in the application.",
          "format": "date-time"
        },
        "banned": {
          "type": "boolean",
          "description": "Indicates whether the user is banned from the application."
        }
      },
      "required": [
        "id",
        "name",
        "email",
        "role",
        "joinDate",
        "lastActive",
        "banned"
      ]
    },
    "FocusSession": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FocusSession",
      "type": "object",
      "description": "Represents a focus session recorded by a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the focus session."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N FocusSession)"
        },
        "duration": {
          "type": "number",
          "description": "The duration of the focus session in minutes."
        },
        "date": {
          "type": "string",
          "description": "The date of the focus session.",
          "format": "date-time"
        },
        "taskTag": {
          "type": "string",
          "description": "A tag or category associated with the focus session."
        }
      },
      "required": [
        "id",
        "userId",
        "duration",
        "date",
        "taskTag"
      ]
    },
    "Task": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Task",
      "type": "object",
      "description": "Represents a task within the study planner.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the task."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Task)"
        },
        "title": {
          "type": "string",
          "description": "The title of the task."
        },
        "subject": {
          "type": "string",
          "description": "The subject or course associated with the task."
        },
        "dueDate": {
          "type": "string",
          "description": "The due date of the task.",
          "format": "date-time"
        },
        "priority": {
          "type": "string",
          "description": "The priority level of the task (e.g., 'high', 'medium', 'low')."
        },
        "completed": {
          "type": "boolean",
          "description": "Indicates whether the task is completed."
        }
      },
      "required": [
        "id",
        "userId",
        "title",
        "subject",
        "dueDate",
        "priority",
        "completed"
      ]
    },
    "Note": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Note",
      "type": "object",
      "description": "Represents a note or PDF document uploaded by a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the note."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Note)"
        },
        "title": {
          "type": "string",
          "description": "The title of the note or document."
        },
        "subject": {
          "type": "string",
          "description": "The subject or course associated with the note."
        },
        "uploader": {
          "type": "string",
          "description": "The name of the user who uploaded the note."
        },
        "date": {
          "type": "string",
          "description": "The date the note was uploaded.",
          "format": "date-time"
        },
        "downloads": {
          "type": "number",
          "description": "The number of times the note has been downloaded."
        },
        "fileUrl": {
          "type": "string",
          "description": "URL of the stored file.",
          "format": "uri"
        }
      },
      "required": [
        "id",
        "userId",
        "title",
        "subject",
        "uploader",
        "date",
        "downloads",
        "fileUrl"
      ]
    },
    "CollabRoom": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CollabRoom",
      "type": "object",
      "description": "Represents a collaborative study room.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the collaboration room."
        },
        "topic": {
          "type": "string",
          "description": "The topic of the study room."
        },
        "createdBy": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N CollabRoom (creator))"
        },
        "memberIds": {
          "type": "array",
          "description": "References to Users. (Relationship: User N:N CollabRoom (members))",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "topic",
        "createdBy",
        "memberIds"
      ]
    },
    "ChatMessage": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ChatMessage",
      "type": "object",
      "description": "Represents a message within a collaboration room.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the chat message."
        },
        "roomId": {
          "type": "string",
          "description": "Reference to CollabRoom. (Relationship: CollabRoom 1:N ChatMessage)"
        },
        "senderId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N ChatMessage (sender))"
        },
        "text": {
          "type": "string",
          "description": "The content of the chat message."
        },
        "timestamp": {
          "type": "string",
          "description": "The date and time the message was sent.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "roomId",
        "senderId",
        "text",
        "timestamp"
      ]
    },
    "MentorChat": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MentorChat",
      "type": "object",
      "description": "Represents a chat session between a user and the AI mentor.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the mentor chat session."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N MentorChat)"
        },
        "messages": {
          "type": "array",
          "description": "An array of messages in the chat session.",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "userId",
        "messages"
      ]
    },
    "AdminLog": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AdminLog",
      "type": "object",
      "description": "Represents a log entry for an action performed by an administrator.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the admin log entry."
        },
        "adminId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N AdminLog (admin))"
        },
        "actionType": {
          "type": "string",
          "description": "The type of action performed by the administrator."
        },
        "target": {
          "type": "string",
          "description": "The target of the administrator's action (e.g., user ID, note ID)."
        },
        "timestamp": {
          "type": "string",
          "description": "The date and time the action was performed.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "adminId",
        "actionType",
        "target",
        "timestamp"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles.  Includes the 'role' field for DBAC. The role must be readable to control access at login.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/focusSessions/{sessionId}",
        "definition": {
          "entityName": "FocusSession",
          "schema": {
            "$ref": "#/backend/entities/FocusSession"
          },
          "description": "Stores focus session data for each user. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "sessionId",
              "description": "The unique identifier of the focus session."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/tasks/{taskId}",
        "definition": {
          "entityName": "Task",
          "schema": {
            "$ref": "#/backend/entities/Task"
          },
          "description": "Stores task data for each user. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "taskId",
              "description": "The unique identifier of the task."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/notes/{noteId}",
        "definition": {
          "entityName": "Note",
          "schema": {
            "$ref": "#/backend/entities/Note"
          },
          "description": "Stores note data for each user. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "noteId",
              "description": "The unique identifier of the note."
            }
          ]
        }
      },
      {
        "path": "/collabRooms/{roomId}",
        "definition": {
          "entityName": "CollabRoom",
          "schema": {
            "$ref": "#/backend/entities/CollabRoom"
          },
          "description": "Stores collaboration room data. Includes denormalized 'memberIds' map for authorization independence.",
          "params": [
            {
              "name": "roomId",
              "description": "The unique identifier of the collaboration room."
            }
          ]
        }
      },
      {
        "path": "/collabRooms/{roomId}/chatMessages/{messageId}",
        "definition": {
          "entityName": "ChatMessage",
          "schema": {
            "$ref": "#/backend/entities/ChatMessage"
          },
          "description": "Stores chat messages for each collaboration room.",
          "params": [
            {
              "name": "roomId",
              "description": "The unique identifier of the collaboration room."
            },
            {
              "name": "messageId",
              "description": "The unique identifier of the chat message."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/mentorChats/{chatId}",
        "definition": {
          "entityName": "MentorChat",
          "schema": {
            "$ref": "#/backend/entities/MentorChat"
          },
          "description": "Stores mentor chat sessions for each user. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "chatId",
              "description": "The unique identifier of the mentor chat session."
            }
          ]
        }
      },
      {
        "path": "/adminLogs/{logId}",
        "definition": {
          "entityName": "AdminLog",
          "schema": {
            "$ref": "#/backend/entities/AdminLog"
          },
          "description": "Stores admin log entries. Only admins can write to this collection.",
          "params": [
            {
              "name": "logId",
              "description": "The unique identifier of the admin log entry."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to ensure Authorization Independence, Role-Based Access Control (DBAC), and efficient querying (QAPs). User roles are managed in the `users` collection. All user-owned data (focus sessions, tasks, notes, mentor chats) are stored in subcollections under the respective user document, enforcing path-based ownership for maximum security and query performance. CollabRooms use a membership map to manage authorization. Here's how the structure supports the core principles:\n\n1.  **Authorization Independence:** The structure avoids hierarchical authorization dependencies by storing all authorization-related data directly within each document or collection. For example:\n    *   Focus Sessions: Each session is stored under `/users/{userId}/focusSessions/{sessionId}`.  Authorization rules can directly verify that `request.auth.uid == userId` without needing to `get()` the user document.\n    *   Collab Rooms: Members are stored as a map `members: {uid1: true, uid2: true}` within the `collabRooms` document.  Security rules check for membership directly on the document, eliminating the need to fetch user roles or other parent data.  The `createdBy` field also contributes to authorization, allowing the creator of a room to have special privileges.\n\n2.  **Clarity of Intent:** The structure clearly separates different types of data based on their access requirements:\n    *   User data is stored under `/users/{userId}`, ensuring that only the user (or an admin) can access it.\n    *   Collab rooms are stored in a flat `/collabRooms` collection, with membership managed via the `members` map. This makes the authorization logic for collab rooms explicit and easy to understand.\n    *   Admin logs are stored in `/adminLogs`, with security rules enforcing that only admins can write to this collection.\n\n3.  **DBAC (No Custom Claims):** User roles are stored directly in the `users` collection (`users/{userId}/role`). This allows security rules to directly access the user's role using `get(/databases/(default)/documents/users/$(request.auth.uid)).data.role` within security rules. If the initial error, \"FirebaseError: Firebase: Error (auth/operation-not-allowed)\", is thrown when the code attempts to update the user's role, then the current security rule will need modification to permit this specific action, with the condition that only administrators can update the role.\n\n4.  **QAPs (Rules are not Filters):** The structure supports secure list operations:\n    *   Listing focus sessions: `list` on `/users/{userId}/focusSessions` is secure because rules can verify `request.auth.uid == userId`.\n    *   Listing collab rooms: `list` on `/collabRooms` requires checking membership in the `members` map, ensuring that only members can access the room details. Segregation ensures that different access control requirements don't end up in the same collection, preventing rule complexity.\n\n5.  **Invariants:** The structure supports data integrity:\n    *   Ownership: Path-based ownership ensures that only the user can modify their data (focus sessions, tasks, notes, etc.).\n    *   Timestamps: Timestamps can be enforced via security rules to ensure that they are set correctly on creation and updates.\n    *   Admin logs: The `adminLogs` collection ensures that all admin actions are logged, providing an audit trail.\n\nDenormalization of authorization context is applied consistently throughout the structure. For instance, while the `CollabRoom` entity has a `createdBy` field referencing a user, the `members` map within the `CollabRoom` *denormalizes* membership information. This crucial denormalization enables security rules to validate user access to a `CollabRoom` directly by inspecting the `members` map, without needing to perform expensive and non-atomic `get()` operations on other documents (e.g., the user document or a separate membership list). Similarly, storing the `userId` within `FocusSession`, `Task`, and `Note` documents enables straightforward, path-based security rules that ensure a user can only access their own data, again without requiring external `get()` calls. This design optimizes both security and performance, aligning with the core principles of Authorization Independence and QAPs.\n\nThe initial error, \"FirebaseError: Firebase: Error (auth/operation-not-allowed)\", reported when attempting to fetch user roles from Firestore on login, indicates that the current security rules likely prevent this operation. To resolve this, the security rules must be modified to permit reading the user's role from the `users` collection, specifically allowing authenticated users to read their own role or allowing admins to read any user's role. Also, ensure that only administrators can update the role.\n"
  }
}